# __1)Определение перемененных__
___

Переменные должны использоваться в верху функции, даже если они определяются ниже по коду. Если переменной присваивается значение, эта запись должна идти отдельной строкой кода; если переменные только объявляются можно писать их одной строкой, но только в самом начале определения. Перед знаком = и после него должны быть пробелы. Переменные должны быть выровнены по левой кромке.

### var yeah, this_is, a, way,

###    foo = 1,

###    bar = 2;

Предполагается использование camelCase стиля именования методов и mixed_underscore для атрибутов и сервисных функций. Подумайте как лучше выразить назначение функции или переменной, скажем массивы лучше именовать во множественном числе, а перед булевыми перемененными использовать is.

___
# __2)Блоки__
___

Из-за того, что используется явное указание точек-с-запятой всегда начинайте фигурную скобку на той строке, где идёт открывающее выражение. Например:


### if (foo) {
 ###   bar();
### }


### if (foo) {
###    foo = 1;
###    return false;
### }

___
# __3)Комментирование__
___
В целом рекомендуется комментировать сложные моменты и игнорировать очевидный код. Не стоит добавлять бессмысленные, личные или расплывчатые комментарии.

Если оказывается что необходимо постоянно что-то комментировать, подумайте над тем не стоит ли разбить код на именованные функции, описывающие его работу.

При работе с откомментированным кодом не забывайте проверять сохраняется ли актуальность данного комментария и исправлять/удалять его.

Для длинных строк нужно использовать /* ... */.

Длинные одно-строчные комментарии должны быть отдельной строчкой, предпочтительно над комментируемым кодом. Так же перед ними стоит оставлять пустую строку.

### var some = "stuff";

### // Делаем цикл

### for (var i = 0; i < 10; i++ ) {
 ###   doIt();
### }

Комментарии внутри строки можно использовать только для описания специфических аргументов в списке формальных параметров:

### function foo(types, selector, data, fn, /*ВНУТРЕННИЙ*/ one ) {
 ###   // do stuff.
### }

Массивы и инициализация объектов
Пустые объекты и массивы не должны содержать пробелов. Однострочные массивы и инициализаторы объектов допустимы только если они умещаются в строку-две.

### var arr = [1, 2, 3];    // Без пробелов после [ или до ].

### var obj = {a: 1, b: 2, c: 3};    // Без пробелов после { или до }.

Отступы многострочных инициализаторов аналогичны таковым у блоков.

### var inset = {
###  top: 10,
### right: 20,
### bottom: 15,
###  left: 12
### };

Обратите внимание на то, что перед двоеточием пробела нет.

### this.rows = [
###    '"Чёртпобериэтоттекст" ',
###    '"Marvin the Paranoid Android" ',
 ###   'the.mice@magrathea.com'
### ];

___
# __4)Вложенные функции__
___
Вложенные функции неплохо подходят для разбиения функционала и могут использоваться свободно. Если функция используется только другой функцией её стоит определить внутри последней.
___
Неудачно:
___
### function foo_plus_bar() {
###    return get_foo_for_foo_plus_bar() + 'bar';
### };
### function get_foo_for_foo_plus_bar() {
###    return 'foo';
### };
___
Удачно:
___
### function foo_plus_bar() {
 ###   function get_foo() {
 ###       return 'foo';
 ###   };
 ###   return get_foo() + 'bar';
### };
Как исключение иногда стоит определять дочернюю функцию вне основной с целью избегания перекрёстных ссылок (см. раздел о замыканиях).

___
# __5)Модульная структура__
___
Общее поведение может быть сгруппировано в отдельные модули:

### function PoweredThing() {
###    this.set_voltage = function set_voltage() {
 ###       //...
###    }
### }
___
### function Laser() {
  ###  PoweredThing.apply(this);
### }
___
### var laser = new Laser();
### laser.set_voltage(100000000);

___
# __6)Циклы for … in …__
___
Не стоит использовать этот метод при обработке массивов.

___
# __7)Модификация прототипов встроенных объектов__
___
К примеру:

### Array.prototype.find = function () {....} 

Встроенные конструкторы не должны модифицироваться! Если нужно расширить функционал встроенных классов создайте новый конструктор, который создаёт объект и добавляет к нему свой функционал.
___
# __8)This__
___
Использование this может сбивать с толку. В целом не стоит использовать его кроме как в конструкторах или совместно с call или apply.

Использование конечных элементов DOM в вызовах событий говорит о непродуманном коде и как бы намекает на необходимость другого подхода.

___
# __9)Eval__
___
Основное назначение eval для десериализации. Если вы используете его для чего-то ещё, вы увлеклись.

___
# __10)Замыкания__
___
Замыкания великолепны. Порой они захватывают дух, однако используя их стоит быть внимательным, особенно если код может работать длительное время.

Рассмотрим пример:

### function foo(element, a, b) {
###    element.onclick = function handle_click() { /* использует a и b */ };
### }

В данном примере создана перекрёстная ссылка, вызывающая утечку памяти. Функция handle_click содержит element в своей области видимости и element содержит handle_click, что означает, что ни одна не может быть удалена.

### function foo(element, a, b) {
###    element.onclick = bar(a, b);
### }

### function bar(a, b) {
###     return function() { /* использует a и b */ }
 ### }
В данном случае создано второе замыкание не содержащее element и исключающее перекрёстную ссылку.
