# __1)Используйте пробелы вместо табуляции__
___

Помимо символа конца строки, символ горизонтального пробела ASCII (0x20), единственный разделитель, который следует использовать в любом месте исходного файла. Это означает, что символы табуляции не используются для отступов.
В руководстве также указывается, что для отступа следует использовать два пробела (а не четыре).

### // bad
### function foo() {
### ∙∙∙∙let name;
### }

### // bad
### function bar() {
### ∙let name;
### }

### // good
### function baz() {
 ### ∙∙let name;
 ###}



___
# __2)Точка с запятой — ОБЯЗАТЕЛНА__
___

Каждая инструкция должна заканчиваться точкой с запятой. Использование автоматической вставки точки с запятой запрещено.
Я не понимаю, почему кто-то может быть против этого утверждения. Регулярное использование точки с запятой, становится предметом дебатов, как и «табуляция против пробелов». Google твёрдо выступает в защиту точки с запятой.


### // bad
### let luke = {}
### let leia = {}
### [luke, leia].forEach(jedi => jedi.father = 'vader')
### // good
### let luke = {};
### let leia = {};
### [luke, leia].forEach((jedi) => {
###   jedi.father = 'vader';
### });

___
# __3)Горизонтальное выравнивание не рекомендуется (но и не запрещается)__
___
Такая практика допустима, но, в целом, не рекомендуется «стилем» Google. Не следует продолжать горизонтальное выравнивание даже в местах, где оно уже применялось.
Горизонтальное выравнивание — это практика добавления дополнительных пробелов в коде, чтобы определённые значения, отображались непосредственно под другими значениями в предыдущих строках.

### // bad
### {
###  tiny:   42,  
###  longer: 435, 
### };
### // good
### {
###  tiny: 42, 
###  longer: 435,
### };


___
# __4)Не используйте var__
___
Объявляйте все переменные с помощью const или let. Используйте const по умолчанию, если переменная не требует переназначения. Ключевое слово var не должно использоваться.
На StackOverflow и в других местах, я все ещё замечаю, что люди используют var в своём коде. Не могу сказать, предают ли они этому особое значение или это просто старая привычка.

### // bad
### var example = 42;
### // good
### let example = 42;
___
# __5)Отдавайте предпочтение стрелочным функциям__
___
Стрелочные функции делают синтаксис лаконичным и устраняют некоторые трудности с ним. Отдавайте предпочтение стрелочным функциям, вместо ключевого слова function, особенно для вложенных функций.
Честно говоря, я думал, что стрелочные функции хороши только тем, что они более краткие и приятны глазу. Оказывается, они также служат очень важной цели.

### // bad
### [1, 2, 3].map(function (x) {
###   const y = x + 1;
###  return x * y;
### });

### // good
### [1, 2, 3].map((x) => {
###   const y = x + 1;
###  return x * y;
### });
___
# __6)Используйте шаблонные строки вместо конкатенации.__
___
Используйте шаблонные строки (разделённые символом `) вместо конкатенации комплексных строк, особенно если используется несколько строковых литералов. Шаблонные строки могут занимать несколько строк.

### // bad
### function sayHi(name) {
###   return 'How are you, ' + name + '?';
### }

### // bad
### function sayHi(name) {
###   return ['How are you, ', name, '?'].join();
### }

### // bad
### function sayHi(name) {
 ### return `How are you, ${ name }?`;
### }

### // good
### function sayHi(name) {
###   return `How are you, ${name}?`;
### }

___
# __7)Не используйте line continuations для длинных строк__
___
Не прерывайте строку внутри строкового литерала обратной косой чертой, в обычных или шаблонных строковых литералах. Несмотря на то, что ES5 допускает это, могут появится неприятные ошибки, если после косой черты окажется пробел. Это будет незаметно при чтении.
Интересно, что Google и Airbnb, не сходятся во мнении об этом правиле (вот спецификация Airbnb).

Google рекомендует объединять более длинные строки (как показано ниже), а руководство по стилю Airbnb, рекомендует ничего с ними не делать и позволить длинным строкам продолжаться столько, сколько им нужно.

### // bad (sorry, this doesn't show up well on mobile)
### const longString = 'This is a very long string that \
###    far exceeds the 80 column limit. It unfortunately \
###    contains long stretches of spaces due to how the \
###    continued lines are indented.';
### // good
### const longString = 'This is a very long string that ' + 
###   'far exceeds the 80 column limit. It does not contain ' + 
###    'long stretches of spaces since the concatenated ' +
###    'strings are cleaner.';

___
# __8)“for… of” — предпочтительная конструкция для циклов for__
___
С ES6, в языке, теперь есть три различных типа цикла for. Использовать можно любой, но предпочтение следует отдавать конструкции for-of, когда это возможно.
По-моему, это странно, но я включил это в свою статью, потому что довольно интересно, что Google объявляет предпочтительный тип цикла for.

У меня всегда было впечатление, что for... in циклы лучше подходят для объектов, а for... of для массивов. «Правильный инструмент для правильной работы».

Хотя спецификация Google не противоречит этой идее, все же интересно знать, что у них есть предпочтение этому циклу, в частности.
___
# __9)Не используйте eval()__
___
Основное назначение eval для десериализации. Если вы используете его для чего-то ещё, вы увлеклись.

### // bad
### let obj = { a: 20, b: 30 };
### let propName = getPropName();  // returns "a" or "b"
### eval( 'var result = obj.' + propName );

### // good
### let obj = { a: 20, b: 30 };
### let propName = getPropName();  // returns "a" or "b"
### let result = obj[ propName ];  //  obj[ "a" ] is the same as obj.a

___
# __10)Одна переменная за раз__
___
Каждое объявление локальной переменной объявляет только одну переменную: такие объявления, как let a = 1, b = 2; не используются.
### // bad
### let a = 1, b = 2, c = 3;
### // good
### let a = 1;
### let b = 2;
### let c = 3;
